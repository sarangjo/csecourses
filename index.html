<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>UW CSE Courses</title>
        <script type="text/javascript" src="d3/d3.min.js"></script>
        <script type="text/javascript" src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
        <script src="http://d3js.org/queue.v1.min.js"></script>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <script type="text/javascript">
            var w = 720;//2400;
            var h = 480;

            // How many levels of classes we're considering
            var LEVELS = 3;
            var NODE_SIZE = 20;

            // Whether nodes are fixed or not
            var fixed = false;

            var link, node, text;

            var filenames = ["csecourses/testcourses"+ LEVELS + ".json", "csecourses/testlinks"+ LEVELS + ".json"];

            loadFiles(filenames);

            /**
             * Loads the given list of file names. Calls onFilesLoaded when files are 
             * done loading.
             */
            function loadFiles(filenames) {
                var q = queue();

                filenames.forEach(function(d) {
                    q.defer(d3.json, d);
                });
                q.awaitAll(onFilesLoaded);
            }

            /**
             * Called when the JSON files have been loaded.
             */
            function onFilesLoaded(err, results) {
                var nodes = results[0];
                var links = results[1];

                // Sort by course number
                nodes.sort(function(a, b) {
                    return a.number - b.number;
                });

                if (fixed) {
                    setupNodes(nodes);
                }

                // Main part of force layout
                var force = d3.layout.force()
                    .size([w, h])
                    .nodes(nodes)
                    .links(links);

                if (!fixed) {
                    // Allows for movement of the nodes
                    force.linkDistance(90)
                        .charge(-300)
                        .on("tick", tick)
                        .start();
                }

                // Access to the SVG container
                var svg = d3.select("body").append("svg")
                    .attr("width", w)
                    .attr("height", h);

                svg.append("defs").selectAll("marker")
                        .data(["regular"]).enter()
                    .append("marker")
                        .attr("id", function(d) { return d; })
                        // Viewport for the arrow
                        .attr("viewBox", "0 -5 10 10")
                        // Offset from the center of the node
                        .attr("refX", 27)
                        .attr("refY", 0)
                        // These are just bounding-box attributes
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                    .append("path")
                        // Draws the triangle, pointing right. M denotes start, L is each point
                        .attr("d", "M0,-5L10,0L0,5");

                // Attaching nodes and links to the visualization
                // Link setup
                link = svg.append("g").selectAll(".link")
                    .data(force.links()).enter()
                    .append("path")
                    .attr("class", "link")
                    // Attaches marker (arrow) to the end of the link
                    // As of now the regular link is just called "regular"
                    .style("marker-end", "url(#regular)");

                // Node setup
                node = svg.append("g").selectAll(".node")
                    .data(force.nodes()).enter()
                    .append("circle")
                    .attr('r', NODE_SIZE)
                    .attr("class", "node");

                if (!fixed) {
                    node.call(force.drag);
                }

                // Text setup
                text = svg.append("g").selectAll(".text")
                    .data(force.nodes()).enter()
                    .append("text")
                    .text(function(d) { return d.number; });

                if (!fixed) {
                    text.attr("x", 25)
                        .attr("y", ".31em");
                }

                if(fixed) {
                    force.on('end', function() {
                        node.attr('cx', function(d) { return d.x; })
                            .attr('cy', function(d) { return d.y; });
                    
                        link.attr('x1', function(d) { return d.source.x; })
                            .attr('y1', function(d) { return d.source.y; })
                            .attr('x2', function(d) { return d.target.x; })
                            .attr('y2', function(d) { return d.target.y; });
    
                        text.attr("x", function(d) { return d.x - 12; })
                            .attr("y", function(d) { return d.y + 5; });
                        
    
                        console.log("Done!");
    
                        d3.select("body").append("p").text("Done Loading!");
                    });
    
                    force.start();
                }
            }

            function tick() {
                link.attr("d", linkLine);
                node.attr("transform", transform);
                text.attr("transform", transform);
            }

            function linkArc(d) {
                var dx = d.target.x - d.source.x,
                    dy = d.target.y - d.source.y,
                    dr = Math.sqrt(dx * dx + dy * dy);
                return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
            }

            function linkLine(d) {
                return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
            }

            function transform(d) {
                return "translate(" + d.x + "," + d.y + ")";
            }

                

            ///////////// HELPER METHODS /////////////

            /**
             * Sorts and sets nodes' positions.
             */
            function setupNodes(nodes) {
                // Sets the positions of the given nodes
                var BASE_X = 60;
                var LEVEL_OFFSET = 150;
                var NODE_OFFSET = 30;
                
                var currentLevel = 1;
                var xCounter = 0;
                var yShift = false;

                nodes.forEach(function(n) {
                    var level = Math.floor(n.number / 100);
                    level = (level != 1 ? level - 2 : level - 1);
                    
                    // Updates level
                    if (level != currentLevel) {
                        currentLevel = level;
                        xCounter = 0;
                    }

                    n.x = BASE_X + (xCounter * (NODE_SIZE + NODE_OFFSET));
                    n.y = (LEVEL_OFFSET / 2) + (level * LEVEL_OFFSET) + (yShift ? 30 : 0);
                    // Doesn't allow force to actually modify the positions of the nodes
                    n.fixed = true;
                    
                    xCounter++;
                    yShift = !yShift;
                });

                console.log(nodes);
            }
        </script>
        <p>Welcome to UW CSE Courses!</p>
    </body>
</html>